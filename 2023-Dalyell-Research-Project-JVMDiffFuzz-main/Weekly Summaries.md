# Weekly Summaries

## Week 1

We discussed the general structure of a java class file (i.e. where to look for instructions), how op codes are written (1 byte opcode + 0 or more bytes of arguments) and the structure of some elements in the java class file (tag length value). There was also the notion of types of input: incomplete being there exists some suffix of bytes that will make the input valid; incorrect being that there exists no such suffix; and complete means that no more bytes can be added to the input, i.e. exploration ends. The two objectives we devised were to 1) identify a JVM and find where the byte code instructions are parsed and 2) find what happens when it’s given an illegal instruction and identify all the supported instructions. I did this for the python jvm implementation and found what instructions it supported, i.e. valid op codes and where it executed them. I then modified the class file and replaced the call to print with an invalid op code, which caused the jvm to crash, reporting an invalid op code. I also researched the exact format of the java class file: would be tedious to design a parser from scratch to find where the instructions are in a class file and modify them so it is likely best to borrow from the python jvm implementation.

## Week 2

 Continued from where the previous week left off. Was able to identify all the supported instructions for the python jvm and what error codes are passed depending on if the instruction is valid or incomplete. This was done in a brute force approach, i.e. simply iterating over all the values allowable in a byte (0 – 255). Will likely look for an industrial jvm (written in C) to explore and test during week 3. Also looked into the “Fast-Failure Feedback” paper to get a better picture of the way in which the fuzzing was done previously; had a look at the code but not quite sure how they work at the moment. Proposal drafting is ongoing: will likely have a draft in the next few days and can fine tune it from there so that it’s all done by the end of week 3. 

## Week 3

Built a fuzzer for the python jvm interpreter that adds one character to the instruction each time and tests whether the input is incorrect, incomplete or complete. Required some light instrumentation, simply to differentiate execution errors from incorrect op codes or incomplete instructions as those would occasionally return the same error. Managed to get some complete sequences, however it could only generate small sequences in a reasonable amount of time. Things to be determined: what to do in the case that we need to go back more than one step, how many constants to use in the class file, i.e. some instructions might be valid with one classfile depending on how big the constant table is and how many local variables are there. 

## Week 4

Further tweaked the fuzzer for the python jvm interpreter that was built last week. In order to solve the issues we ran into last time I used a simple backtracking method since the maximum amount of bytes that the python JVM would read in addition to the instruction was 2. So if we get stuck for around ~50 different attempts, we backtrack back 2 bytes and try a new instruction. @ bytes is obviously the maximum we need to backtrack, it could be one byte so perhaps it might be a good idea to keep track of the instructions that require arguments and mark where they are in the input string to easily change/go back where needed. Using this method I was able to improve the performance of the fuzzer significantly both in time and the length of the input. From testing it, the highest complete sequence of instructions I got was 103. The code for the fuzzer has also been placed onto the github as well with documentation. 

## Week 5

Worked on increasing the coverage for the fuzzer. I noticed that none of the branching instructions were being covered since they were triggering errors instead of returning "Incomplete" so that was fixed. Note: often the byte corresponding to the instruction to jump to is outlandishly large (usually in the 1,000s or 10,000s) and so it will fill the space in between with random bytes. This is fine for some cases since the jump skips those bytes, however, if the program were to jump back to some byte we skipped that presents problems. If we jump back and then return incomplete, we will indefinitely add bytes to the end, not to say the middle; similar problem for an error. Backtracking doesn't really help since we have no way of differentiating this jump back incomplete case from a normal incomplete case. Aside from that, we're getting mostly all the instructions which is good. I did manage to get a class file of ~5000 bytes, but I think it would take too long to think about getting a 64KB file. Also finished automating modifying the class file: previously I was simply hardcoding values and seeing where the code was but I've been able to do it in a systematic way using the classes defined in the Python JVM for help to find the relevant items in the class file. Suprisingly, the python JVM doesn't account for static float variables so I added in the functionality to process them since it is necessary in order to find where the code for main is stored.

## Week 6

Started loooking for JVMs to use. Have initially settled on Amazaon Java 20 and have been testing the existing fuzzer on the JVM so far. So far I'm simply using the error messages from the JVM to determine incomplete, incorrect or valid sequences. For the most part this is ok, however, I have noticed that the JVM will usually return incomplete for ~50 bytes and then find an incorrect instruction around say byte 16 so the 2 byte backtracking doesn't work here and needs to be modified. Perhaps something else is going on here under the hood compared to the relatively simple python JVMs way of running each btye until it errors. 

## Week 7

Continued fuzzing the Amazon Java 20 JVM. After some debugging I realised that the error messages that I was getting in the previous week were because the attached LineNumberTable in the class file was no longer valid (its essentially a list of all the lines and their PC values to help debug where an error occurred), so compiling without any debug information removed the error. Given that the debug information referred to the previous code anyways it's not as if we are losing anything by doing so. Aside from that the fuzzer mostly works, I can get sequences of a bit more than 100 instructions. Only trouble is that sometimes I will get a NullPointerException only when I try to force an end to the sequence (say around byte 200ish). From what I can gather this is because I am loading from some sort of array in the bytecode, but that array is null and for whatever reason it does not seem to give the NullPointerException at any time before that. So instead of just removing the instructions I am going to test to see if during the enumeration, adding a return character causes a null point exception and then treat those as any other error. Note that I have not required instrumenting the JVMs yet as their error codes have proved sufficient.

## Week 8

Am now able to generate valid class files for the Amazon Java 20 JVM. Getting good coverage with the instructions, however, instructions involving control flow are going to be difficult to implement. The reason for this is that in a class file, there is an attribute called a Stack Map Frame Table that has entries for each jump that occurs. The problem therefore, is that if we want to randomly have jump instructions, we need to be able to create new entries in the stack map frame table in order for them to be valid instructions, which also means we need to keep track of which instructions perform jumps and how to properly update the table with new entries. Does anyone have any thoughts about how to proceed with this? 

## Week 9

Developed a program to stack the class file with 1000s of local variables and static functions. Also improved the backtracking. Previously, we were always going back 5 bytes (since the max was a 1 byte instruction followed by 4 bytes of arguments) which led to backtracking through previously ok instructions and meant sequences had a hard time getting longer than 10 bytes. Now, I'm able to find the exact instruction that caused the error and backtrack to that and then keep going with the program. Because of that we are now able to get some more coverage with instructions that require arguments (although not all of them), and so coverage is sitting at about 62%. Main problems still remaining are instructions requiring certain data types in the stack: e.g. 2 doubles on the top of the stack; instructions requiring a valid index into the array of constants; e.g. a valid index corresponding to the position of a certain static method; and instructions requiring jumps. 

## Week 10

Mostly just bug fixing and improving the randomly generated class file template with stacked variables. Have not been able to improve coverage as of yet since I still need to work out how to deal with the issues I mentioned last week. Going to do more research into how to deal with those so that we can start improving coverage. 

## Week 11

Having done a bit of research into improving coverage I've come to a bit of a wall. In order to perform jumps, I cannot simply add/change the bytes in the code section as it requires information outside of that section as I've previously said, and I don't think there's much of a way around this. The other coverage is limited by how much 'luck' is involved with getting 
valid stacks and constant pool indexes, that whilst I think it should be theoretically possible that we can increase our coverage, it's simply not materialising in our tests. Given this setback, I've instead pushed forward with the other part of the project, the 'differential fuzzing' part. So the other JVM I chose was the comparable Java 20 Zulu JVM. Now in setting up the testing of the two JVMs there were two ways I approached this. 1) For each byte that we add onto the code section, run the Amazon JVM and then run the Zulu JVM on the file and test to see that we are getting the same output at every stage. This is of course preferable, since we can see the error messages at each point, which in most cases give the state of the stack, locals, and of course what error has occured at what point. However, this approach is somewhat infeasible: we can either switch JVMs during the running of the process, which dramatically reduces the runtime of the program, making it infeasible to even get sequence > 10; the other approach is to simply store all the error messages and the corresponding bytes, however, from a space perspective this also blows out dramatically. 2) The second approach, which is the one that I have set up at the moment, is simply running the Amazon JVM and creating say 10 class files of some length, and then collecting all the output from those class files being run with the Amazon JVM and comparing them to the output with the Zulu JVM. This way we can more easily test more class files of greater length, however, losing that more in depth state by state analysis that we got with 1). I've also automated gathering coverage from all the multiple class files and testing that. All of this exists in a bash script, so you can just run that and it'll perform the fuzzing, do the testing with the other JVM and test the overall coverage produced by the class files.

## Week 12

Mostly making sure everything was in order for the presentation on Monday. Downloaded vagrant and have got most of it set up, so will do the final touchings in the coming week. Have also started downloading other versions of java to test with the coverage that we do have at the moment and redeveloping the tests to allow for more versions of java. 